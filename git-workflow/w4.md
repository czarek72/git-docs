Yes — many teams ship **only from `main` + tags** and never create `release/*` branches. It works well if you keep `main` always deployable and you don’t need long stabilization windows.

## How “release by tagging main” works (the story)

### Ongoing development

* Developers work on short-lived feature branches.
* Everything merges into `main` via PR.
* `main` is expected to be green (build + tests passing).

### When you want to release

* Someone (often a Release Manager or Tech Lead) chooses a specific commit on `main` that is green and approved for production.
* That exact commit is given a **version tag** (e.g., `v1.3.0`).
* CI/CD is configured so **deployments happen from tags** (or tags trigger a release pipeline).

### If you need a patch release

* You don’t “patch the tag” (tags point to a specific immutable commit).
* You make a fix via the normal flow (feature branch → PR → `main`).
* Then you create a new tag on a later `main` commit (e.g., `v1.3.1`) and deploy that.

### What happens if production needs an urgent fix

* Same: fix goes into `main` quickly, tests pass, then you tag the fix commit and deploy it.

This model assumes you can ship straight from `main` (or at least from a “release candidate commit” on main).

---

## What you need in place for this to be safe

1. **Strong CI gates on `main`**

* Backend and frontend build/tests (path-aware is fine)
* Linting/format checks
* Optional: integration tests, contract tests
* Optional: security scanning

2. **Feature flags for risky/unfinished features**

* So incomplete work can merge but stay disabled.

3. **A clear “release candidate” rule**
   Examples:

* “Only tag commits that passed the full pipeline”
* “Only tag commits that have QA sign-off”
* “Only tag commits created by release manager role”

4. **Versioning discipline**

* Either your pipeline writes version metadata at build time from the tag
* Or you update versions via a PR before tagging (more overhead)

---

## Pros (why teams like it)

### ✅ Simpler branch model

* Only `main` + feature branches
* Less process overhead and fewer “where should this fix go?” questions

### ✅ Single source of truth

* No divergence between `main` and `release/*`
* No cherry-picking back and forth

### ✅ Fast release cadence

* Great for continuous delivery: you can ship many times a week/day

### ✅ Less merge/cherry-pick pain

* Release branches often create conflict work; tagging avoids most of that

### ✅ Clear traceability

* Each release is a tag pointing to an exact commit
* Easy to reproduce a release build if your build is deterministic

---

## Cons (where it breaks down)

### ❌ Harder to do long stabilization

If you need a week of QA “freeze” while dev continues merging new features, tagging-only gets tricky:

* You can’t easily keep shipping fixes to a stable line without also carrying whatever else is merged into `main` during that time.

You *can* enforce a “release freeze” on main, but then main stops moving — which defeats some benefits.

### ❌ Harder to maintain multiple supported versions

If customers run `1.2.x` and `1.3.x` concurrently and you must patch both:

* tagging-only is painful because fixes for old versions may not apply cleanly to the current `main`.
* you usually end up needing maintenance branches (like `release/1.2`) anyway.

### ❌ Risk of “main is not always releasable”

If your team can’t consistently keep `main` green and deployable (integration instability, environment drift, large changes), tagging-only can lead to:

* tagging “almost good” commits
* last-minute fire drills
* pressure to rush QA

### ❌ Version bump / release notes flow can be awkward

If you keep versions in code (e.g., Maven `version`, Angular app version) you must decide:

* do you bump versions before tagging (PR + review), or
* do you generate versions from tag during build (recommended), or
* do you allow “dirty” state where versions don’t match tags (confusing)

### ❌ Emergency hotfix may be slower if `main` moved far ahead

If `main` contains large refactors not yet deployed, and production needs a quick patch:

* applying the fix on today’s `main` might be risky
* you might *want* a stable branch based on the deployed version

This is exactly what release branches are for.

---

## When tagging-only is a great fit

* You release frequently (daily/weekly)
* You only support “latest” in production
* CI is strong and fast
* You use feature flags for incomplete work
* Your system is easy to test end-to-end
* You don’t need long release stabilization

## When you probably want release branches

* You need a multi-day stabilization window
* You support multiple versions in production
* You often need “fix only, no new features” releases
* Merging into main is noisy / main not always stable

---

## A common hybrid (best of both worlds)

Most teams that start with tagging-only adopt this rule later:

* Default: **tag `main` for releases**
* Exception: create a **temporary `release/x.y` branch only when stabilization is needed** (e.g., big release, holiday freeze, major migrations)
* For emergencies on old versions: create a **maintenance branch** for that version line

This keeps daily life simple but gives you an escape hatch.

---

If you tell me your reality in two bullets:

1. Do you support only the latest release or multiple versions?
2. How long is QA/stabilization typically (hours vs days/weeks)?
   …I can recommend either pure tagging-only, or a hybrid rule that stays simple but covers your worst-case scenarios.

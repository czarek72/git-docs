Below is a practical, end-to-end Git playbook for a **Spring Boot + Angular monorepo** (e.g., `backend/` + `frontend/`). It’s written to work even when some teammates touch only one side, while still keeping the repo consistent, reviewable, and releasable.

---

# Git workflow for a Spring Boot + Angular monorepo

## Repo shape (example)

```
repo/
  backend/
    ... Spring Boot ...
  frontend/
    ... Angular ...
  docs/
  .github/            (PR templates, workflows)
  .gitignore
  README.md
```

Key idea: **one repo, one history**, but changes are usually scoped to a folder, and reviews/CI can be path-aware.

---

## 1) Repo creation (starting from zero)

### 1.1 Create repo locally

```bash
mkdir my-monorepo
cd my-monorepo
git init
git branch -M main
```

### 1.2 Add initial structure

```bash
mkdir backend frontend docs
touch README.md .gitignore
git add .
git commit -m "chore: initial monorepo structure"
```

### 1.3 Connect to remote and push

Create an empty repo in your Git hosting (GitHub/GitLab/Bitbucket), then:

```bash
git remote add origin <REMOTE_URL>
git push -u origin main
```

### 1.4 Protect `main` (recommended)

Do this in your Git hosting UI:

* Require PRs (no direct push to `main`)
* Require CI checks
* Require at least 1–2 approvals
* Optional: require linear history / squash merges (depending on preference)

---

## 2) Cloning and setup for developers

### 2.1 Clone

```bash
git clone <REMOTE_URL>
cd my-monorepo
```

### 2.2 Configure identity (first time only)

```bash
git config --global user.name "Your Name"
git config --global user.email "you@company.com"
```

### 2.3 Recommended local Git settings (team consistency)

**Rebase pulls by default** (reduces merge noise):

```bash
git config --global pull.rebase true
```

**Auto-stash when rebasing**:

```bash
git config --global rebase.autoStash true
```

**Better conflict markers / rerere** (remembers past resolutions):

```bash
git config --global rerere.enabled true
```

---

## 3) Branching strategy (recommended default)

### Option A (recommended): Feature branches + PRs into `main`

* `main` is always releasable
* Developers create short-lived branches:

  * `feat/<ticket>-short-desc`
  * `fix/<ticket>-short-desc`
  * `chore/...`

Create a branch:

```bash
git switch main
git pull
git switch -c feat/123-add-login
```

### Option B: Trunk-based with very short branches

Same as Option A, just stricter: branches live hours–1 day, merge quickly, use feature flags if needed.

### Option C: Release branches (only if you must)

If you do staged releases:

* `main` for ongoing work
* `release/1.4` for stabilization
* `hotfix/...` for urgent fixes

Create release branch:

```bash
git switch main
git pull
git switch -c release/1.4
git push -u origin release/1.4
```

---

## 4) Day-to-day developer workflow

### 4.1 Start work (always from up-to-date `main`)

```bash
git switch main
git pull
git switch -c feat/123-add-login
```

### 4.2 Make changes (backend only / frontend only / both)

Stage only what you intend to commit:

```bash
git status
git add backend/...
# or
git add frontend/...
# or
git add -p            # interactive staging (highly recommended)
```

Commit:

```bash
git commit -m "feat(auth): add login endpoint"
```

Push your branch:

```bash
git push -u origin feat/123-add-login
```

Open a PR in the UI.

---

## 5) Keeping your branch up-to-date

### 5.1 Rebase onto latest `main` (clean history)

```bash
git fetch origin
git rebase origin/main
```

If your repo uses “merge commits” policy instead, do:

```bash
git fetch origin
git merge origin/main
```

### 5.2 After rebasing, force-push safely

Rebase rewrites history, so:

```bash
git push --force-with-lease
```

**Never** use plain `--force` unless you really know why.

---

## 6) How backend-only and frontend-only devs work efficiently

### 6.1 Use path-based staging and logs

Stage backend only:

```bash
git add backend/
git commit -m "fix(api): handle null status"
```

See history only for frontend:

```bash
git log --oneline -- frontend/
```

See changes in backend between two refs:

```bash
git diff origin/main...HEAD -- backend/
```

### 6.2 Partial checkout (sparse checkout) for big repos

If the repo is large and someone rarely touches the other folder:

Enable sparse checkout:

```bash
git clone --filter=blob:none <REMOTE_URL>
cd my-monorepo
git sparse-checkout init --cone
git sparse-checkout set backend
```

Later, add frontend too:

```bash
git sparse-checkout set backend frontend
```

> This keeps the working tree focused while still being a single repo/branch.

---

## 7) PR rules for monorepo health (highly recommended)

### 7.1 Commit message convention (example)

Pick one convention and stick to it. Example:

* `feat(frontend): ...`
* `feat(backend): ...`
* `fix(frontend): ...`
* `fix(backend): ...`
* `chore: ...`
* `docs: ...`

### 7.2 PR scope guidelines

* Prefer PRs that are:

  * either backend-only, frontend-only, or clearly coordinated (both)
* If touching both, explain why and how to test both.

### 7.3 Enforce owners by folder (CODEOWNERS)

Add `.github/CODEOWNERS` like:

```
/backend/  @backend-team
/frontend/ @frontend-team
```

Now PRs automatically request the right reviewers.

---

## 8) Handling common scenarios and the exact commands

### Scenario A: “I accidentally committed changes to the wrong folder”

If not pushed yet:

```bash
git reset --soft HEAD~1
git restore --staged .
git add backend/
git commit -m "fix(backend): ..."
# optionally commit frontend separately
git add frontend/
git commit -m "fix(frontend): ..."
```

If already pushed and PR exists, you can still fix with new commits (simplest).

---

### Scenario B: “I committed secrets or something sensitive”

If it’s truly sensitive, don’t just delete in a new commit—history still contains it.

Immediate steps:

1. Rotate the secret (credentials/token).
2. Remove it from the repo.
3. Rewrite history (requires team coordination).

Typical tool: `git filter-repo` (preferred) or BFG. The exact remediation depends on your hosting and policies; treat as an incident.

---

### Scenario C: “I need to undo a commit safely (shared branch)”

Use revert (adds a new commit that undoes):

```bash
git revert <COMMIT_SHA>
git push
```

Avoid `reset --hard` on shared branches.

---

### Scenario D: “My PR has conflicts with main”

Update and resolve with rebase:

```bash
git fetch origin
git rebase origin/main
```

Resolve conflicts:

```bash
git status
# edit files to resolve
git add <resolved-files>
git rebase --continue
```

If you want to abort:

```bash
git rebase --abort
```

Then push updated branch:

```bash
git push --force-with-lease
```

---

### Scenario E: “I want to combine/fix commits before merging”

Interactive rebase:

```bash
git fetch origin
git rebase -i origin/main
```

In the editor:

* `pick` keeps commit
* `squash` merges commit into previous
* `reword` edits message

Then:

```bash
git push --force-with-lease
```

---

### Scenario F: “I need to move a commit from one branch to another”

Cherry-pick:

```bash
git switch feat/other-branch
git cherry-pick <COMMIT_SHA>
git push
```

If multiple commits:

```bash
git cherry-pick <SHA1> <SHA2> <SHA3>
# or a range:
git cherry-pick <OLD_SHA>^..<NEW_SHA>
```

---

### Scenario G: “I started work on main by mistake”

Create a branch from current state:

```bash
git switch -c feat/123-from-main-mistake
git push -u origin feat/123-from-main-mistake
```

Then reset local main back:

```bash
git switch main
git fetch origin
git reset --hard origin/main
```

---

### Scenario H: “I have local changes but need to switch branches”

Use stash:

```bash
git stash push -m "wip: partial form"
git switch other-branch
# later
git stash pop
```

---

### Scenario I: “I need to examine who changed something”

Blame a file:

```bash
git blame backend/src/main/java/.../MyFile.java
```

Or for a directory:

```bash
git log -- backend/
```

---

### Scenario J: “Two people changed backend and frontend in same PR”

This is allowed, but keep review clear.

Helpful diff views:

```bash
git diff origin/main...HEAD -- backend/
git diff origin/main...HEAD -- frontend/
```

---

## 9) Tags and releases

Tag a release on `main`:

```bash
git switch main
git pull
git tag -a v1.3.0 -m "Release v1.3.0"
git push origin v1.3.0
```

List tags:

```bash
git tag --list
```

---

## 10) Hotfix flow (when production needs an urgent fix)

If you release from tags on `main`:

```bash
git switch main
git pull
git switch -c hotfix/urgent-null-pointer
# fix...
git add backend/
git commit -m "fix(backend): prevent null pointer in payment flow"
git push -u origin hotfix/urgent-null-pointer
```

PR -> merge -> tag release.

If you have a `release/x.y` branch, base hotfix off that:

```bash
git fetch origin
git switch -c hotfix/urgent origin/release/1.4
```

---

## 11) Large file handling (optional)

Avoid committing build artifacts and dependencies. Use `.gitignore` properly.

If you truly must store binaries, use Git LFS:

```bash
git lfs install
git lfs track "*.zip"
git add .gitattributes
git commit -m "chore: track zips with git lfs"
```

---

## 12) Monorepo-specific best practices

### 12.1 Don’t commit generated build outputs

Typical ignores:

* `backend/target/`
* `frontend/dist/`
* `node_modules/`

### 12.2 Prefer folder-scoped CI

Have CI run:

* backend pipeline when `backend/**` changes
* frontend pipeline when `frontend/**` changes
* both when shared config changes

This is not a Git feature, but it makes monorepo life much better.

### 12.3 Keep shared changes explicit

When editing shared files (root configs, tooling), call it out in PR description and ensure both sides still build.

---

## 13) Quick command reference (copy/paste)

**Create branch**

```bash
git switch main && git pull
git switch -c feat/123-desc
```

**Stage selectively**

```bash
git add -p
```

**Commit**

```bash
git commit -m "feat(frontend): add profile page"
```

**Push**

```bash
git push -u origin HEAD
```

**Update branch (rebase)**

```bash
git fetch origin
git rebase origin/main
git push --force-with-lease
```

**Undo safely**

```bash
git revert <SHA>
```

**Stash**

```bash
git stash push -m "wip"
git stash pop
```

**Folder-only diff**

```bash
git diff origin/main...HEAD -- backend/
```

---

## 14) Team policy checklist (what to agree on once)

1. **Default branch:** `main`
2. **Merging style:** squash merge OR merge commits OR rebase+merge (pick one)
3. **Commit message convention:** choose one and enforce in reviews
4. **Branch naming:** `feat/`, `fix/`, `chore/`, `hotfix/`
5. **CODEOWNERS:** owners per folder
6. **CI checks required:** backend/frontend based on paths
7. **Rule:** never force-push to `main` (force-push allowed only on personal feature branches)

---

If you tell me which merge policy you want (squash vs merge-commits vs rebase-merge) and whether you maintain release branches, I can tailor this into a stricter “official team standard” with exact rules and examples that match your process.

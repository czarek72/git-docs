## Rebase vs merge as a team policy

### What each one *means*

* **Merge** brings another branch’s history into yours by creating a **merge commit** (unless fast-forward). It **does not rewrite history**.
* **Rebase** “moves” your commits to a new base by **replaying them** on top of another branch. It **rewrites history** (new commit SHAs).

### Why policy matters

The “right” choice depends on what you value most:

* **Auditability / true history** → merge is safer
* **Linear history / clean PRs** → rebase is cleaner
* **Shared branches** → avoid rewriting history (so: merge)

---

## Recommended policy for most teams (monorepo-friendly)

### 1) `main`: protected, always releasable

* ✅ PRs only
* ✅ No force-push
* ✅ Prefer **squash merge** or **rebase+merge** in the PR UI (pick one)
* ✅ Require CI + approvals

**Pick ONE of these styles for merging PRs into `main`:**

#### Option A — Squash merge (most common)

* PR becomes **one commit** on `main`
* Keeps `main` very clean
* Makes rollback easy (revert one commit)

**Tradeoff:** loses detailed intermediate commits (but PR still has discussion)

#### Option B — Rebase & merge (linear, keeps commits)

* PR commits appear linearly on `main` (no merge commit)
* Keeps meaningful commit granularity

**Tradeoff:** still rewrites the PR branch commits as they’re applied (fine)

#### Option C — Merge commits (true branch structure)

* Preserves exact branching history
* Useful if you like seeing “feature branch merged” points

**Tradeoff:** `main` gets noisier over time

**My practical recommendation:**

* If your team doesn’t care about preserving every intermediate commit: **Squash merge**
* If you do care and devs write good commits: **Rebase & merge**

---

### 2) Feature branches: rebase is encouraged

Policy:

* ✅ Developers should **rebase feature branches onto `main`** to stay current
* ✅ Force-push allowed on feature branches **owned by one person**
* ✅ Use `--force-with-lease` only

Typical:

```bash
git switch feat/123-x
git fetch origin
git rebase origin/main
git push --force-with-lease
```

---

### 3) Shared branches (release, develop, integration): **merge only**

Policy:

* ✅ **Never rebase** a branch multiple people use
* ✅ **Never force-push** shared branches
* ✅ Update them by merging:

  * merge `main` into `release/x.y` for stabilization
  * cherry-pick fixes into release branches when needed
  * merge release back to main if you keep long-lived releases

Rule of thumb:

> **Rebase only private branches. Merge shared branches.**

---

# Tutorial: working with shared branches like `release/x.y`

Below is a solid, low-drama release-branch workflow used in many teams.

## A. Creating a release branch

When you’re ready to stabilize a version:

```bash
git switch main
git pull
git switch -c release/1.4
git push -u origin release/1.4
```

**Branch protections for `release/1.4`** (in hosting UI):

* PRs only
* No force-push
* Required CI
* Required approvals (often from release owner)

---

## B. What changes are allowed on a release branch?

Typical policy:

* ✅ Bug fixes only
* ✅ Small, low-risk changes
* ✅ Version bumps, release notes
* ❌ No new features (unless explicitly approved)

This matters because release branches are about **reducing uncertainty**.

---

## C. How fixes land in a release branch (two safe patterns)

### Pattern 1 (recommended): Fix goes to `main` first, then cherry-pick to release

This keeps `main` as the “source of truth”.

#### 1) Create fix branch from main

```bash
git switch main
git pull
git switch -c fix/456-null-pointer
```

Make fix, commit, push, PR into `main`:

```bash
git add backend/
git commit -m "fix(backend): prevent null pointer in payment"
git push -u origin fix/456-null-pointer
```

Merge PR into `main`.

#### 2) Cherry-pick that fix into `release/1.4`

```bash
git fetch origin
git switch release/1.4
git pull
git cherry-pick <SHA_FROM_MAIN>
git push
```

If conflicts happen during cherry-pick:

```bash
# fix files
git add <files>
git cherry-pick --continue
```

**Why this is great:**

* Fix is guaranteed in `main`
* Release gets only what it needs
* Audit trail stays clean

---

### Pattern 2: Fix branch created from release, then merged back to release (and later ported to main)

Use this only when the fix depends heavily on release-only state.

```bash
git switch release/1.4
git pull
git switch -c fix/789-release-only
# fix...
git commit -am "fix: ..."
git push -u origin fix/789-release-only
```

Open PR into `release/1.4`, merge it.

Then you **must port it back** to `main` (usually by cherry-pick, sometimes by PR):

```bash
git switch main
git pull
git cherry-pick <SHA_FROM_RELEASE>
git push
```

**Risk:** teams sometimes forget to port back → bug reappears in next release.

---

## D. Keeping the release branch up-to-date with main

There are two styles; pick one:

### Style 1: Minimal drift (merge main into release periodically)

This brings in changes that happened after branch cut. It can be useful, but it increases risk.

```bash
git switch release/1.4
git pull
git merge origin/main
git push
```

**Only do this if you have a clear reason**, because it can accidentally pull features into release.

### Style 2 (recommended for stability): No merging main into release

After branch cut:

* release receives only **cherry-picked fixes**
* `main` continues forward independently

This is the safest “stabilize and ship” approach.

---

## E. Tagging the release

After validating `release/1.4` at a specific commit:

```bash
git switch release/1.4
git pull
git tag -a v1.4.0 -m "Release v1.4.0"
git push origin v1.4.0
```

(Then your CI/CD can deploy from the tag.)

---

## F. After release: what happens next?

### If you cherry-picked fixes from main → main already contains fixes ✅

You might just close the release branch later.

### If release had unique commits → make sure main gets them

Cherry-pick any release-only commits back into main.

---

# Shared-branch “dos and don’ts” (the rules that prevent disasters)

## DO

* **Merge** into shared branches via PRs
* Use **cherry-pick** to port fixes between branches
* Protect shared branches from force-push
* Keep release branches short-lived where possible

## DON’T

* Don’t rebase `release/*`
* Don’t force-push `release/*`
* Don’t “just fix it directly on the release branch” without PR (unless emergency + policy)

---

# Practical recipes (copy/paste)

### Update your feature branch (clean PR)

```bash
git switch feat/123
git fetch origin
git rebase origin/main
git push --force-with-lease
```

### Bring a fix from main into a release

```bash
git switch release/1.4
git pull
git cherry-pick <SHA>
git push
```

### Hotfix off release (then port back)

```bash
git switch release/1.4
git pull
git switch -c hotfix/999
# fix...
git commit -am "fix: ..."
git push -u origin hotfix/999
# PR -> merge into release/1.4
# then:
git switch main
git pull
git cherry-pick <SHA_FROM_RELEASE>
git push
```

---

If you tell me which PR merge mode you want for `main` (squash vs rebase+merge vs merge commit), I can turn this into a strict “Team Git Standard” with:

* branch naming rules
* required checks
* who approves what (backend/front owners)
* and a release checklist (tagging, version bumps, changelog).

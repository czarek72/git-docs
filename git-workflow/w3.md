Here’s a single, consistent “story” you can adopt as your team’s official process. I’ll describe **who creates which branch, when it’s used, what gets merged where, and when branches are deleted**, starting from day 0. No commands, just the narrative.

I’ll assume a common setup:

* `main` = always releasable
* short-lived feature branches for daily work
* short-lived `release/x.y` branches when you’re preparing a release
* optional `hotfix/x.y.z` branches only for urgent production fixes
* PRs required for anything that ends up in `main` or `release/*`

---

## Cast of characters

* **Repo Admin / Tech Lead**: sets up repo, protections, decides release cut
* **Backend Devs**: mostly touch `backend/`
* **Frontend Devs**: mostly touch `frontend/`
* **Release Manager** (could be the Tech Lead or rotating role): owns the release branch and shipping
* **QA** (if you have it): validates release branch builds

---

# Phase 0 — Day 0: repository is born

### What exists at the beginning

* The Tech Lead creates the repo and creates a single long-lived branch: **`main`**.
* `main` contains:

  * the monorepo structure (`backend/`, `frontend/`)
  * build config / CI setup
  * basic README and conventions

### Rules established on day 0

* Nobody pushes directly to `main`.
* Everyone merges via PR.
* `main` is treated as “always deployable” (or at least “should build green”).

**No other long-lived branches exist at this point.**

---

# Phase 1 — Early development: features start flowing

### What developers do every day

* A backend developer starts work on a backend task. They create a **feature branch** from `main`, named after the work item (ticket/feature).
* A frontend developer does the same for a frontend task.
* Each feature branch is owned by the person (or pair) doing that work.

### What happens to feature branches

* The feature branch lives just long enough to implement the change and pass review.
* When ready, the developer opens a PR **into `main`**.
* Reviewers are requested based on folder ownership (backend team reviews backend changes, etc.).
* CI runs checks (backend build/test when backend changed, frontend build/test when frontend changed).
* After approval + green checks, the PR is merged into `main`.
* **Right after merge**, the feature branch is **deleted** (usually via the PR UI automatically).

### What `main` looks like during this phase

* `main` keeps advancing with many small merges.
* `main` is the integration point for both backend and frontend work.
* If something is too big, it’s still split into smaller PRs or guarded by feature flags, so `main` stays healthy.

**Key pattern:**
Feature branches are created from `main`, merged into `main`, then deleted.
No long-lived “develop” branch is necessary.

---

# Phase 2 — Preparing the first release: a release branch is cut

After some weeks, you decide: “We’re ready to ship version 1.0.”

### Who does what

* The **Release Manager** (or Tech Lead) decides a cutoff moment: “Release 1.0 will include everything currently in `main` as of today.”
* They create a branch named **`release/1.0`** from the current `main`.

Now two branches matter:

* `main` (keeps moving with new work)
* `release/1.0` (stabilization zone)

### What changes are allowed where

From this moment, the team follows a strict split:

#### On `main`

* Feature development continues normally.
* New features can keep landing in `main` for the next release (1.1, 2.0, whatever).

#### On `release/1.0`

* Only release-critical changes are allowed:

  * bug fixes
  * small safe tweaks
  * versioning, release notes
  * configuration fixes needed for production
* **No new features** should be introduced here.

### How changes get into `release/1.0`

This is the part that often confuses teams, so here’s the consistent rule:

**Rule: fixes are implemented on `main` first, then copied to `release/1.0`.**

So the story looks like this:

1. QA finds a bug in the release candidate.
2. A developer creates a small fix branch **from `main`** (not from release).
3. The fix is reviewed and merged into `main`.
4. The Release Manager then “brings that fix” into `release/1.0` (without bringing unrelated new work).

The outcome:

* `main` stays the single source of truth for fixes.
* The release branch gets only the specific fixes it needs.
* You avoid accidentally dragging new features into the release.

### What happens next

* QA validates `release/1.0` repeatedly.
* More critical bugs → more fixes → same flow.
* Eventually, QA signs off: release branch is good.

---

# Phase 3 — Shipping the release

### Who does what

* Release Manager tags and ships the exact state of `release/1.0`.
* Production is deployed from that known-good state.

At the moment of release:

* `main` already contains all fixes that were needed (because fixes landed in main first).
* `release/1.0` contains those fixes as well, plus perhaps only release-specific metadata (version/changelog).

---

# Phase 4 — After release: what happens to the release branch

### Short-lived release branches (recommended)

Once version 1.0 is shipped:

* If you don’t plan to patch 1.0 anymore:

  * `release/1.0` is **deleted** (after a short cooling-off period).
* If you expect patch releases (1.0.1, 1.0.2):

  * keep `release/1.0` alive for maintenance.

### If you keep it for patch releases

Then the branch becomes a “maintenance line.”

The pattern for a patch release:

* QA reports a production bug affecting 1.0 users.
* A developer makes the fix on `main` first (so it’s not lost).
* The fix is then copied into `release/1.0`.
* Release Manager ships `1.0.1` from `release/1.0`.

Eventually, when 1.0 is no longer supported, `release/1.0` is deleted.

---

# Phase 5 — Emergency production fix: hotfix branches (only when needed)

Sometimes production breaks and you cannot wait.

### The rule for hotfixes

A hotfix branch is created **from the branch/tag that represents what’s running in production**.

Example story:

* Production is running `v1.0.0`, which corresponds to `release/1.0`.
* A critical outage occurs.
* Release Manager creates **`hotfix/1.0.1-critical`** from `release/1.0` (or from tag `v1.0.0`).
* A developer commits the minimal fix there.
* PR goes into `release/1.0` (or directly into the hotfix branch based on policy), QA verifies quickly.
* Release Manager ships `1.0.1`.

**After shipping:**

* The hotfix changes must be made present in `main` too (either by copying them back, or by having already implemented the fix in main if time allowed).
* The hotfix branch is deleted after use.
* `release/1.0` may remain if you still support 1.0.

Hotfix branches are always:

* created for emergencies
* merged and shipped quickly
* deleted quickly

---

# What branches exist over the lifetime of the project (summary)

### Always present

* **`main`** — exists from day 0 forever

### Created often, deleted often

* **Feature branches** — created by developers, deleted after PR merge

### Created per release, usually temporary

* **`release/x.y`** — created by Release Manager at release cut, deleted when that line is no longer maintained

### Created rarely, deleted immediately after use

* **`hotfix/x.y.z-*`** — created by Release Manager during emergency, deleted after release

---

# Who creates/modifies/deletes what (one-glance responsibilities)

### Tech Lead / Repo Admin

* Creates repo and `main`
* Sets rules (PR-only, branch protections)
* Sometimes acts as Release Manager

### Developers (backend/frontend)

* Create feature branches from `main`
* Push commits to their feature branches
* Open PRs into `main`
* Do not directly touch `release/*` unless assigned and via PR

### Release Manager

* Creates `release/x.y` from `main` at the cut
* Approves what goes into `release/x.y` (only critical fixes)
* Coordinates QA
* Ships tags/releases
* Deletes release/hotfix branches when done

### QA

* Tests `release/x.y`
* Reports bugs and verifies fixes

---

# The “order of operations” timeline (very explicit)

1. `main` is created on day 0.
2. Devs repeatedly:

   * create feature branch → merge into `main` → delete feature branch
3. When it’s time to ship:

   * Release Manager creates `release/1.0` from `main`
4. During stabilization:

   * fixes are made on `main` → copied into `release/1.0`
5. Release ships from `release/1.0`
6. After release:

   * either delete `release/1.0` (if no patches)
   * or keep it for patch releases
7. Emergencies:

   * create `hotfix/...` from production line → ship → copy back to `main` → delete hotfix

---

If you want the story adjusted to your reality, the two knobs that change the plot are:

1. Do you want **release branches** at all, or only tags from `main`?
2. Do you support **multiple versions** in production (needing long-lived maintenance branches), or only the latest?
